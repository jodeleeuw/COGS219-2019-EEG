---
title: "R Notebook"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(readr)
library(dplyr)
library(ggplot2)
library(ez)
library(tidyr)
library(grid)
library(scales)
library(mapproj)
```


# Subject Exclusions

We are removing subjects who do not have at least 80% good segments.

```{r message=FALSE, warning=FALSE}
subject.segment.log <- read_csv('data/tidy/eeg-segment-count.csv')
good.subjects <- subject.segment.log %>%
  filter(P >= 0.8) %>%
  pull(Subject)
```

# Behavioral Data

Loading in the data and filtering to only good subjects.

```{r message=FALSE, warning=FALSE}
all.behavioral.data <- read_csv('data/tidy/behavioral-data-tidy.csv', progress = FALSE) %>%
  filter(participant_id %in% good.subjects)
```

Graph

```{r message=FALSE, warning=FALSE}
subject.level <- all.behavioral.data %>% 
  filter(phase == 'test', target_lag %in% c(2,8)) %>%
  mutate(correct = as.numeric((correct == 'TRUE'))) %>%
  group_by(participant_id, distractor_type, target_lag) %>%
  summarize(accuracy = mean(correct))

summary.data <- subject.level %>%
  group_by(distractor_type, target_lag) %>%
  summarize(M=mean(accuracy), SD=sd(accuracy), SE=sd(accuracy)/sqrt(n()))

ggplot(summary.data, aes(x=target_lag, y=M, color=distractor_type, group=distractor_type))+
  geom_line(size=1)+
  geom_point(size=2)+
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), size=1,width=0.2)+
  theme_bw()+
  theme(panel.grid=element_blank())
```

ANOVA

```{r message=FALSE, warning=FALSE}
behavioral.anova <- ezANOVA(subject.level, dv=accuracy, wid=participant_id, within=c(target_lag, distractor_type))
behavioral.anova$ANOVA
```

# EEG Data

We start by loading in the tidy EEG data. See the `generate-tidy-eeg-data.R` file for the pre-processing steps that produced this file.

```{r message=FALSE, warning=FALSE}
# use progress=FALSE because progress bar seems to slow down read_csv in R notebooks.
eeg.data <- read_csv('data/tidy/eeg-data-tidy.csv', progress= FALSE) %>%
  filter(subject %in% good.subjects)
```

We will also load the sensor location data to help us to create topographic maps.

```{r}
sensor_reference <- read_csv('data/sensorreference.csv')
```

```{r}
sensor_reference <- sensor_reference %>%
  mutate(
    length = sqrt(x^2 + y^2 + z^2),
    x.unit = x / length,
    y.unit = y / length,
    z.unit = z / length,
    lat = asin(z.unit) * 90 / (pi / 2),
    long = atan2(x.unit, y.unit) * 90 / (pi / 2)
  )

z <- mapproject(sensor_reference$long, sensor_reference$lat, projection = "azequidistant", orientation=c(90,0,0))

sensor_reference$x <- z$x
sensor_reference$y <- -z$y

sensor_reference <- sensor_reference %>% select(electrode, x,y)
```


## N2

### Distractor Pictures

Kennedy et al. start by isolating the N2 in response to the distractor images by subtracting the lag 8 baseline from the negative and neutral lag 8 conditions.

We calculate the difference wave at each electrode for each subject in each condition.

```{r}
n2.distractor.data <- eeg.data %>%
  filter(lag.condition == "Lag8", electrode %in% c(64,68,69,89,94,95)) %>%
  mutate(hemisphere = if_else(electrode > 70, "right","left")) %>%
  select(-lag.condition)

n2.distractor.baseline.data <- n2.distractor.data %>% 
  filter(distractor.condition == "Baseline") %>%
  mutate(baseline.voltage = voltage) %>%
  select(-voltage, -distractor.condition)

n2.distractor.difference.waves <- n2.distractor.data %>%
  left_join(n2.distractor.baseline.data, by=c("subject", "t", "electrode", "hemisphere")) %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-voltage, -baseline.voltage) %>%
  filter(distractor.condition != "Baseline")
```

A two-factor ANOVA (hemisphere x distractor type) in the time window 185-275ms, on peak negative amplitude. (First average over hemisphere, then find peak)

```{r message=FALSE, warning=FALSE}
n2.distractor.anova.data <- n2.distractor.difference.waves %>%
  filter(t %in% 185:275) %>%
  group_by(subject, hemisphere, distractor.condition, t) %>%
  summarize(M = mean(difference.wave)) %>%
  group_by(subject, hemisphere, distractor.condition) %>%
  summarize(peak = min(M))

n2.distractor.anova <- ezANOVA(n2.distractor.anova.data, wid=subject, dv=peak, within=c(hemisphere, distractor.condition))

n2.distractor.anova$ANOVA
```

Follow up t-tests.

First we have to collapse over hemisphere. Note that we take the MIN rather than average when collapsing over hemisphere since we are looking for peak negative amplitude.
(Code is shown here to provide a model for performing t-tests.

```{r}
n2.distractor.t.test.data <- n2.distractor.anova.data %>%
  group_by(subject, distractor.condition) %>%
  summarize(peak = min(peak))
```

Is negative less than neutral?

**Note: In an earlier version of this Notebook I neglected to make this a paired t-test!**

```{r}
t.test(peak ~ distractor.condition, data=n2.distractor.t.test.data, alternative="less", paired=TRUE)
```


Follow up one-sample, one-tailed t-tests to see if N2s are less than 0.

Negative condition:

```{r}
# the pull() command extracts the column from the data frame.
n2.distractor.t.test.data %>%
  filter(distractor.condition == "Negative") %>%
  pull(peak) %>%
  t.test(mu=0, alternative="less")
```

Neutral condition:

```{r}
n2.distractor.t.test.data %>%
  filter(distractor.condition == "Neutral") %>%
  pull(peak) %>%
  t.test(mu=0, alternative="less")
```

Basic plotting of the ERPs. (You should make a better plot than this!)
This is analogous to Figure 3.


```{r warning=FALSE}
n2.distractor.erp <- n2.distractor.difference.waves %>%
  group_by(distractor.condition, t) %>%
  summarize(M = mean(difference.wave))

ggplot(n2.distractor.erp, aes(x=t, y=M, color=distractor.condition))+
  geom_line()+
  geom_vline(xintercept = 0)+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,1000), expand=c(0,0))+
  annotate("rect", xmin=185,xmax=275,ymin=-1,ymax=2.5, alpha=0.2)+
  theme_bw()
```

*Note that it is weird that the average waveforms in the target window are positive, but the t-tests for peak negative amplitude in this window are significantly below 0! Why might that happen, and what does it potentially say about peak negative amplitude as a way of establishing whether there is a significantly below 0 effect?*

Generate data for topographic plots for Distractor N2.
```{r}
n2.distractor.topo.data <- eeg.data %>%
  filter(lag.condition == "Lag8") %>%
  select(-lag.condition)

n2.distractor.baseline.topo.data <- n2.distractor.topo.data %>% 
  filter(distractor.condition == "Baseline") %>%
  mutate(baseline.voltage = voltage) %>%
  select(-voltage, -distractor.condition)

n2.distractor.topo.difference.waves <- n2.distractor.topo.data %>%
  left_join(n2.distractor.baseline.topo.data, by=c("subject", "t", "electrode")) %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-voltage, -baseline.voltage) %>%
  filter(distractor.condition != "Baseline", t== 225) %>% group_by(electrode) %>%
  summarise(amplitude = mean(difference.wave)) %>% left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(64,68,69,89,94,95), "key", "not"))
```


```{r}

theme_topo <- function(base_size = 12)
  {
  theme_bw(base_size = base_size) %+replace%
      theme(
            rect             = element_blank(),
            line             = element_blank(),
            axis.text = element_blank(),
            axis.title = element_blank()
           )
}

circleFun <- function(center = c(0,0), r, npoints = 100) {
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}

headShape <- circleFun(c(0, 0), round(max(sensor_reference$x)), npoints = 100) # 0
nose <- data.frame(x = c(-.5,0,.5),y=c(1.95,2.3,1.95))

ggplot(headShape,aes(x,y))+
  geom_path(color="grey")+
  geom_text(data = sensor_reference,
            aes(x, y, label = electrode))+
  geom_line(data = nose,
            aes(x, y, z = NULL), color="grey")+
  theme_topo()+
  coord_equal()


head <- geom_path(data = headShape,
            aes(x,y,z = NULL,fill = NULL),
            size = .5)
nose_shape <- geom_path(data = nose,
            aes(x, y, z = NULL, fill = NULL),
            size = .5)
```

```{r}
#Define Matlab-style Jet colourmap
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

#Draw our map!
ggplot(headShape,aes(x,y))+
  geom_line(data = nose,aes(x, y, z = NULL),size = 1.5)+
  geom_path(size = 1.5)+
  geom_point(data = n2.distractor.topo.difference.waves,aes(x,y,colour = amplitude),size = 3)+
  scale_colour_gradientn(colours = jet.colors(10),guide = "colourbar", oob = squish)+ #note: oob = squish forces everything outside the colour limits to equal nearest colour boundary (i.e. below min colours = min colour)
  theme_topo()+
  coord_equal()
```

```{r}
rmax <- 3   #specify a maximum boundary for the grid
gridRes <- 67 #specify the interpolation grid resolution

## Create a function to perform Matlab's v4 interpolation.
## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation

v4Interp <- function(df, xo, yo, rmax = 3, gridRes = 67) {
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights
      }
  }
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  #return(list(x = xo[,1],y = yo[1,],z = outmat))
  return(outDf)
}

maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = n2.distractor.topo.difference.waves$x,
                     y = n2.distractor.topo.difference.waves$y,
                     z = n2.distractor.topo.difference.waves$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = n2.distractor.topo.difference.waves,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = n2.distractor.topo.difference.waves,
             aes(x,y, color = key_electrode),
             size = 1.5) +
  scale_color_manual(values = c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-2.5,2.5),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```
```{r}
n2.distractor.topo.difference.waves.overall <- n2.distractor.topo.data %>%
  left_join(n2.distractor.baseline.topo.data, by=c("subject", "t", "electrode")) %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-voltage, -baseline.voltage) %>%
  filter(distractor.condition != "Baseline", t %in% 500:1000) %>% group_by(electrode,t) %>%
  summarise(amplitude = mean(difference.wave)) %>% left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(64,68,69,89,94,95), "key", "not"))

rmax <- 3   #specify a maximum boundary for the grid
gridRes <- 67 #specify the interpolation grid resolution


maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

interpV4 <- data.frame()
## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z
for (i in seq(500, 1000, 5)) {
  n2.d.overall.spec.t <- n2.distractor.topo.difference.waves.overall %>% filter(t == i)
  testDat<- data.frame(x = n2.d.overall.spec.t$x,
                     y = n2.d.overall.spec.t$y,
                     z = n2.d.overall.spec.t$amplitude)

  #Create the interpolation grid
  xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
  yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

  interpV4_mini <- v4Interp(testDat, xo, yo)
  interpV4_mini <- gather(interpV4_mini,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 
  
  interpV4_mini <- interpV4_mini %>% mutate(t=i)

  interpV4 <- rbind(interpV4,interpV4_mini)
}


interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark

ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = n2.distractor.topo.difference.waves,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = n2.distractor.topo.difference.waves,
             aes(x,y, color = key_electrode),
             size = 1.5) +
  scale_color_manual(values = c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-2.5,2.5),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

```


### Target Pictures

We need to subtract each lag 8 condition from the corresponding lag 2, which isolates the appearance of the target.

```{r}
n2.target.data <- eeg.data %>%
  filter(electrode %in% c(64,68,69,89,94,95)) %>%
  mutate(hemisphere = if_else(electrode > 70, "right","left"))

n2.target.difference.waves <- n2.target.data %>%
  spread(lag.condition, voltage) %>%
  mutate(difference.wave = Lag2 - Lag8) %>%
  select(-Lag2, -Lag8)
```

ANOVA on **mean** difference (Kennedy et al. are not clear about whether this should be peak or mean...) in the time window 405-585ms after distractor.

```{r message=FALSE, warning=FALSE}
n2.target.anova.data <- n2.target.difference.waves %>%
  filter(t %in% 405:585) %>%
  group_by(subject, hemisphere, distractor.condition) %>%
  summarize(M=mean(difference.wave))

n2.target.anova <- ezANOVA(n2.target.anova.data, wid=subject, dv=M, within=c(hemisphere, distractor.condition))
n2.target.anova$ANOVA
```

Post-hoc tests

```{r}
n2.target.t.test.data <- n2.target.anova.data %>%
  group_by(subject, distractor.condition) %>%
  summarize(M=mean(M))
```

Baseline vs. Negative. Is Baseline LESS than Negative, one-tailed?

**Note about the direction of the alternative hypothesis for one-tailed tests.** In R you can specify the alternative as `"less"` or `"greater"` for a one-tailed test. Which one you should choose depends on the order of the factor, i.e., is R subtracting Baseline from Negative, or Negative from Baseline. You can find the order of the factor by typing:

```{r}
levels(factor(n2.target.t.test.data$distractor.condition))
```

R will subtract levels that appear later in the list FROM levels that appear earlier in the list. So if we want to know if Negative - Baseline is a positive number (i.e., Baseline is less than Negative) then the alternative has to be `"less"` because R will do the subtraction as Baseline - Negative.

```{r}
t.test(M ~ distractor.condition, 
       data = (n2.target.t.test.data %>% filter(distractor.condition != "Neutral")),
       paired = TRUE,
       alternative="less")
```

Baseline vs. Neutral. Is Baseline LESS than Neural, one tailed?
```{r}
t.test(M ~ distractor.condition, 
       data = (n2.target.t.test.data %>% filter(distractor.condition != "Negative")),
       paired = TRUE,
       alternative="less")
```

Negative vs. Neutral. Is Neutral LESS than Negative, one tailed?

```{r}
t.test(M ~ distractor.condition, 
       data = (n2.target.t.test.data %>% filter(distractor.condition != "Baseline")),
       paired = TRUE,
       alternative="greater")
```


Basic plot (Figure 4)

```{r warning=FALSE}
n2.target.plotting.data <- n2.target.difference.waves %>% 
  group_by(distractor.condition, t) %>%
  summarize(M=mean(difference.wave))

ggplot(n2.target.plotting.data,  aes(x=t, y=M, color=distractor.condition))+
  geom_line()+
  geom_vline(xintercept=0)+
  geom_vline(xintercept=200)+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,800), expand=c(0,0))+
  annotate("rect", xmin=405,xmax=585,ymin=-3.5,ymax=1, alpha=0.2)+
  theme_bw()
```

Topographic data for plot for N2 target
```{r}
n2.target.topo.difference.waves <- eeg.data %>% filter(t==450) %>%
  spread(lag.condition, voltage) %>%
  mutate(difference.wave = Lag2 - Lag8) %>%
  select(-Lag2, -Lag8) %>% group_by(electrode) %>%
  summarise(amplitude = mean(difference.wave)) %>% left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(64,68,69,89,94,95), "key", "not"))
```


```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = n2.target.topo.difference.waves$x,
                     y = n2.target.topo.difference.waves$y,
                     z = n2.target.topo.difference.waves$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = n2.target.topo.difference.waves,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = n2.target.topo.difference.waves,
             aes(x,y,color=key_electrode),
             size = 1.5)+
  scale_colour_manual(values=c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-2,2),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```



## P3b

### Target Pictures

Subtract Lag 8 from Lag 2 for each condition. Target electrodes: 54, 55, 79, 78, 61, 62. Time window: 635-995.

```{r}
p3b.target.data <- eeg.data %>%
  filter(electrode %in% c(54,55,79,78,61,62))

p3b.target.difference.waves <- p3b.target.data %>%
  spread(lag.condition, voltage) %>%
  mutate(difference.wave = Lag2 - Lag8) %>%
  select(-Lag2, -Lag8) %>%
  group_by(subject, t, distractor.condition) %>%
  summarize(M.difference.wave = mean(difference.wave))
```

ANOVA

```{r message=FALSE, warning=FALSE}
p3b.target.anova.data <- p3b.target.difference.waves %>%
  filter(t %in% 635:995) %>%
  group_by(subject, distractor.condition) %>%
  summarize(M = mean(M.difference.wave))

p3b.target.anova <- ezANOVA(p3b.target.anova.data, wid=subject, dv=M, within=c(distractor.condition))
p3b.target.anova$ANOVA
```

Post-hoc tests

Is Baseline GREATER than Neutral?

```{r}
t.test(M ~ distractor.condition, 
       data = (p3b.target.anova.data %>% filter(distractor.condition != "Negative")),
       paired = TRUE,
       alternative="greater")
```

Is Baseline GREATER than Negative?

```{r}
t.test(M ~ distractor.condition, 
       data = (p3b.target.anova.data %>% filter(distractor.condition != "Neutral")),
       paired = TRUE,
       alternative="greater")
```

Is Neutral GREATER than Negative?

```{r}
t.test(M ~ distractor.condition, 
       data = (p3b.target.anova.data %>% filter(distractor.condition != "Baseline")),
       paired = TRUE,
       alternative="less")
```

Plot (Figure 5)

```{r}

p3b.target.plot.data <- p3b.target.difference.waves %>%
  group_by(t, distractor.condition) %>%
  summarize(M = mean(M.difference.wave))

ggplot(p3b.target.plot.data, aes(x=t,y=M, color=distractor.condition))+
  geom_line()+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,1200), expand=c(0,0))+
  annotate("rect", xmin=635,xmax=995,ymin=-4,ymax=5, alpha=0.2)+
  theme_bw()
```

Create data for p3b target topographic map.
```{r}
p3b.target.topo.difference.waves <- eeg.data %>%
  filter(t == 720) %>%
  spread(lag.condition, voltage) %>%
  mutate(difference.wave = Lag2 - Lag8) %>%
  select(-Lag2, -Lag8) %>%
  group_by(subject, distractor.condition, electrode) %>%
  summarize(M.difference.wave = mean(difference.wave)) %>% 
  group_by(electrode) %>% summarise(amplitude = mean(M.difference.wave)) %>% left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(54,55,79,78,61,62), "key", "not"))
```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = p3b.target.topo.difference.waves$x,
                     y = p3b.target.topo.difference.waves$y,
                     z = p3b.target.topo.difference.waves$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = p3b.target.topo.difference.waves,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = p3b.target.topo.difference.waves,
             aes(x,y, color=key_electrode),
             size = 1.5)+
  scale_color_manual(values=c("white","grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-4,4),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```

### Distractor Pictures

Subtract Lag 8 Baseline from Lag 8 Neg and Neu. Time window: 400-550ms.
Then merge in lag 2 baseline - lag 8 baseline. *Note that this means the baseline condition is looking at something different than the other conditions.*

```{r}
p3b.distractor.data <- eeg.data %>%
  filter(electrode %in% c(54,55,79,78,61,62)) %>%
  filter(lag.condition == "Lag8") %>%
  select(-lag.condition)

p3b.distractor.baseline <- p3b.distractor.data %>%
  filter(distractor.condition == "Baseline") %>%
  mutate(baseline.voltage = voltage) %>%
  select(-voltage, -distractor.condition)
  
# need to merge in lag 2 baseline - lag 8 baseline
p3b.distractor.baseline.difference <- eeg.data %>%
  filter(electrode %in% c(54,55,79,78,61,62)) %>%
  filter(distractor.condition == "Baseline") %>%
  spread(lag.condition, voltage) %>%
  mutate(difference.wave = Lag2 - Lag8) %>%
  select(-Lag2, -Lag8)

p3b.distractor.difference.waves <- p3b.distractor.data %>%
  inner_join(p3b.distractor.baseline, by=c("subject", "t", "electrode")) %>%
  filter(distractor.condition != "Baseline") %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-baseline.voltage, -voltage) %>%
  rbind(p3b.distractor.baseline.difference)

```

ANOVA

```{r echo=FALSE, message=FALSE, warning=FALSE}
p3b.distractor.anova.data <- p3b.distractor.difference.waves %>%
  filter(t %in% 400:550) %>%
  group_by(subject, distractor.condition) %>%
  summarize(M=mean(difference.wave))

p3b.distractor.anova <- ezANOVA(p3b.distractor.anova.data, wid=subject, dv=M, within=distractor.condition)
p3b.distractor.anova$ANOVA
```

Post-hoc tests

Is Baseline LESS than Neutral?

```{r echo=FALSE}
t.test(M ~ distractor.condition, 
       data = (p3b.distractor.anova.data %>% filter(distractor.condition != "Negative")),
       paired = TRUE,
       alternative="less")
```

Is Baseline LESS than Negative?

```{r echo=FALSE}
t.test(M ~ distractor.condition, 
       data = (p3b.distractor.anova.data %>% filter(distractor.condition != "Neutral")),
       paired = TRUE,
       alternative="less")
```

Is Neutral LESS than Negative?

```{r echo=FALSE}
t.test(M ~ distractor.condition, 
       data = (p3b.distractor.anova.data %>% filter(distractor.condition != "Baseline")),
       paired = TRUE,
       alternative="greater")
```

Plot (Figure 6)

```{r echo=FALSE, warning=FALSE}
p3b.distractor.plot.data <- p3b.distractor.difference.waves %>%
  group_by(distractor.condition, t) %>%
  summarize(M=mean(difference.wave))

ggplot(p3b.distractor.plot.data, aes(x=t, y=M, color=distractor.condition))+
  geom_line()+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,1000), expand=c(0,0))+
  annotate("rect", xmin=400,xmax=550,ymin=-2,ymax=3, alpha=0.2)+
  theme_bw()
```

Create data for topographic maps for P3b distractor
```{r}
p3b.distractor.topo.data <- eeg.data %>%
  filter(t == 485) %>%
  filter(lag.condition == "Lag8") %>%
  select(-lag.condition, -t)

p3b.distractor.topo.baseline <- p3b.distractor.topo.data %>%
  filter(distractor.condition == "Baseline") %>%
  mutate(baseline.voltage = voltage) %>%
  select(-voltage, -distractor.condition)
  
# need to merge in lag 2 baseline - lag 8 baseline
p3b.distractor.topo.baseline.difference <- eeg.data %>%
  filter(t == 485) %>%
  filter(distractor.condition == "Baseline") %>%
  spread(lag.condition, voltage) %>%
  mutate(difference.wave = Lag2 - Lag8) %>%
  select(-Lag2, -Lag8, -t)

p3b.distractor.topo.difference.waves <- p3b.distractor.topo.data %>%
  inner_join(p3b.distractor.topo.baseline, by=c("subject", "electrode")) %>%
  filter(distractor.condition != "Baseline") %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-baseline.voltage, -voltage) %>% rbind(p3b.distractor.topo.baseline.difference) %>%
  group_by(electrode) %>% summarise(amplitude = mean(difference.wave)) %>%
  left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(54,55,79,78,61,62), "key", "not"))

```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = p3b.distractor.topo.difference.waves$x,
                     y = p3b.distractor.topo.difference.waves$y,
                     z = p3b.distractor.topo.difference.waves$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = p3b.distractor.topo.difference.waves,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = p3b.distractor.topo.difference.waves,
             aes(x,y, color=key_electrode),
             size = 1.5)+
    scale_color_manual(values=c("white","grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-1.5,1.5),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```

## Posterior Positivity

Remove lag 8 baseline from lag 8 neutral and negative, as in the N2 analysis. But the electrodes are different here: 64, 68, 69, 96, 100, 101.
Critical time window: 405-615ms.

```{r}
pp.data <- eeg.data %>%
  filter(lag.condition == "Lag8", electrode %in% c(64,68,69,96,100,101)) %>%
  mutate(hemisphere = if_else(electrode > 70, "right","left")) %>%
  select(-lag.condition)

pp.baseline.data <- pp.data %>% 
  filter(distractor.condition == "Baseline") %>%
  mutate(baseline.voltage = voltage) %>%
  select(-voltage, -distractor.condition)

pp.difference.waves <- pp.data %>%
  left_join(pp.baseline.data, by=c("subject", "t", "electrode", "hemisphere")) %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-voltage, -baseline.voltage) %>%
  filter(distractor.condition != "Baseline")
```

ANOVA

```{r echo=FALSE, message=FALSE, warning=FALSE}
pp.data.anova <- pp.difference.waves %>%
  filter(t %in% 405:615) %>%
  group_by(subject, distractor.condition, hemisphere) %>%
  summarize(M = mean(difference.wave))

pp.anova <- ezANOVA(pp.data.anova, wid=subject, dv=M, within=c(hemisphere, distractor.condition))
pp.anova$ANOVA
```


Plot (Figure 7)

```{r echo=FALSE, warning=FALSE}
pp.data.plot <- pp.difference.waves %>%
  group_by(t, distractor.condition) %>%
  summarize(M = mean(difference.wave))

ggplot(pp.data.plot, aes(x=t, y=M, color=distractor.condition))+
  geom_line()+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,800), expand=c(0,0))+
  annotate("rect", xmin=405,xmax=615,ymin=-1,ymax=2, alpha=0.2)+
  theme_bw()
  
```

```{r}
pp.topo.data <- eeg.data %>%
  filter(lag.condition == "Lag8", t==470) %>%
  select(-lag.condition, -t)

pp.topo.baseline.data <- pp.topo.data %>%
  filter(distractor.condition == "Baseline") %>%
  mutate(baseline.voltage = voltage) %>%
  select(-voltage, -distractor.condition)
  
pp.topo.difference.waves <- pp.topo.data %>%
  left_join(pp.topo.baseline.data, by=c("subject", "electrode")) %>%
  mutate(difference.wave = voltage - baseline.voltage) %>%
  select(-voltage, -baseline.voltage) %>%
  filter(distractor.condition != "Baseline") %>% group_by(electrode) %>%
  summarise(amplitude = mean(difference.wave)) %>% left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(64,68,69,96,100,101), "key", "not"))
```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = pp.topo.difference.waves$x,
                     y = pp.topo.difference.waves$y,
                     z = pp.topo.difference.waves$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = pp.topo.difference.waves,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = pp.topo.difference.waves,
             aes(x,y, color=key_electrode),
             size = 1.5)+
  scale_color_manual(values=c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-1.5,1.5),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```

## Correct vs. Incorrect

Load the segmented data for correct v. incorrect. Only looking at Lag 2 negative distractor condition, because that's where most errors are!

```{r message=FALSE, warning=FALSE}
eeg.data.correct.incorrect <- read_csv('data/tidy/eeg-data-correct-incorrect-tidy.csv', progress=FALSE) %>% 
  filter(subject %in% good.subjects)
```

### Distractor N2 and Posterior Positivity

Finding difference wave (correct trials - incorrect trials)

```{r}
# NOTE: Kennedy et al. are ambiguous about which electrodes are the correct set here. They state that it is the same as the prior electrode set, but used slightly different electrode sets for the N2 and PP analyses. The list of electrodes may need to change.

n2.pp.correct.incorrect <- eeg.data.correct.incorrect %>%
  filter(electrode %in% c(64,68,69,89,94,95))

n2.pp.correct.incorrect.difference.wave <- n2.pp.correct.incorrect %>%
  spread(correct.condition, voltage) %>%
  mutate(difference.wave = Incorrect - Correct) %>%
  select(-Correct, -Incorrect)
```

Time window 250-350ms for N2. One sample t-test: Is difference wave significantly less than 0?

```{r}
n2.pp.correct.incorrect.difference.wave %>%
  filter(t %in% 250:350) %>%
  group_by(subject) %>%
  summarize(M = mean(difference.wave)) %>%
  pull(M) %>%
  t.test(mu=0, alternative = "less")
```

Time window 410-650ms for posterior positivity. Is difference wave significantly greater than 0?

```{r}
n2.pp.correct.incorrect.difference.wave %>%
  filter(t %in% 410:650) %>%
  group_by(subject) %>%
  summarize(M = mean(difference.wave)) %>%
  pull(M) %>%
  t.test(mu=0, alternative = "greater")
```

Plot

```{r warning=FALSE}
n2.pp.correct.incorrect.plot.data <- n2.pp.correct.incorrect %>%
  group_by(correct.condition, t) %>%
  summarize(M = mean(voltage))

n2.pp.correct.incorrect.difference.wave.plot.data <- n2.pp.correct.incorrect.difference.wave %>%
  group_by(t) %>%
  summarize(M = mean(difference.wave))

ggplot(n2.pp.correct.incorrect.plot.data, aes(x=t,y=M,color=correct.condition))+
  geom_line()+
  geom_line(data=n2.pp.correct.incorrect.difference.wave.plot.data, aes(color=NA))+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,800), expand=c(0,0))+
  annotate("rect", xmin=250,xmax=350,ymin=-8,ymax=2, alpha=0.2)+
  annotate("rect", xmin=410,xmax=650,ymin=-8,ymax=2, alpha=0.2)+
  theme_bw()
```

```{r}
n2.pp.topo.correct.incorrect.difference.wave <- eeg.data.correct.incorrect %>%
  filter(t == 290 | t==535 ) %>%
  spread(correct.condition, voltage) %>%
  mutate(difference.wave = Incorrect - Correct) %>%
  select(-Correct, -Incorrect) %>% group_by(electrode, t) %>% summarise(amplitude = mean(difference.wave)) %>% left_join(sensor_reference, by="electrode")

n2.topo.correct.incorrect.difference.wave <- n2.pp.topo.correct.incorrect.difference.wave %>%
  filter(t == 290) %>% mutate(key_electrode = if_else(electrode %in% c(64,68,69,89,94,95), "key", "not"))

pp.topo.correct.incorrect.difference.wave <- n2.pp.topo.correct.incorrect.difference.wave %>%
  filter(t == 535) %>% mutate(key_electrode = if_else(electrode %in% c(64,68,69,96,100,101), "key", "not"))
```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = n2.topo.correct.incorrect.difference.wave$x,
                     y = n2.topo.correct.incorrect.difference.wave$y,
                     z = n2.topo.correct.incorrect.difference.wave$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = n2.topo.correct.incorrect.difference.wave,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = n2.topo.correct.incorrect.difference.wave,
             aes(x,y, color=key_electrode),
             size = 1.5)+
  scale_color_manual(values=c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-1.5,1.5),
                       guide = "colourbar",
                       oob = squish)+
  head+
  nose_shape+
  coord_equal()

v4plot
```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = pp.topo.correct.incorrect.difference.wave$x,
                     y = pp.topo.correct.incorrect.difference.wave$y,
                     z = pp.topo.correct.incorrect.difference.wave$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = pp.topo.correct.incorrect.difference.wave,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = pp.topo.correct.incorrect.difference.wave,
             aes(x,y, color=key_electrode),
             size = 1.5)+
  scale_color_manual(values=c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-1.5,1.5),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```

### Distractor and Target P3b

Finding difference wave (correct trials - incorrect trials)

```{r}
p3b.correct.incorrect <- eeg.data.correct.incorrect %>%
  filter(electrode %in% c(54,55,79,78,61,62))

p3b.correct.incorrect.difference.wave <- p3b.correct.incorrect %>%
  spread(correct.condition, voltage) %>%
  mutate(difference.wave = Incorrect - Correct) %>%
  select(-Correct, -Incorrect)
```

Time window 400-550ms. Is difference wave significantly greater than 0?

```{r echo=FALSE}
p3b.correct.incorrect.difference.wave %>%
  filter(t %in% 400:550) %>%
  group_by(subject) %>%
  summarize(M = mean(difference.wave)) %>%
  pull(M) %>%
  t.test(mu=0, alternative = "greater")
```

Time window 635-995ms. Is difference wave significantly less than 0?

```{r echo=FALSE}
p3b.correct.incorrect.difference.wave %>%
  filter(t %in% 635:995) %>%
  group_by(subject) %>%
  summarize(M = mean(difference.wave)) %>%
  pull(M) %>%
  t.test(mu=0, alternative = "less")
```

Plot

```{r}
p3b.correct.incorrect.plot.data <- p3b.correct.incorrect %>%
  group_by(correct.condition, t) %>%
  summarize(M = mean(voltage))

p3b.correct.incorrect.difference.wave.plot.data <- p3b.correct.incorrect.difference.wave %>%
  group_by(t) %>%
  summarize(M = mean(difference.wave))
```

```{r echo=FALSE}
ggplot(p3b.correct.incorrect.plot.data, aes(x=t,y=M,color=correct.condition))+
  geom_line()+
  geom_line(data=p3b.correct.incorrect.difference.wave.plot.data, aes(color=NA))+
  scale_y_reverse()+
  scale_x_continuous(limits = c(-200,1200), expand=c(0,0))+
  annotate("rect", xmin=400,xmax=550,ymin=-2,ymax=4, alpha=0.2)+
  annotate("rect", xmin=635,xmax=995,ymin=-2,ymax=4, alpha=0.2)+
  theme_bw()
```

Producing topographic plot data
```{r}
p3b.topo.correct.incorrect.difference.wave <- eeg.data.correct.incorrect %>%
  filter( t == 500 | t == 800) %>%
  spread(correct.condition, voltage) %>%
  mutate(difference.wave = Incorrect - Correct) %>%
  select(-Correct, -Incorrect) %>% group_by(electrode, t) %>% 
  summarise(amplitude = mean(difference.wave)) %>%
  left_join(sensor_reference, by="electrode") %>% mutate(key_electrode = if_else(electrode %in% c(54,55,79,78,61,62), "key", "not"))

p3b.target.topo.correct.incorrect.difference.wave <- p3b.topo.correct.incorrect.difference.wave %>% 
  filter(t == 800)

p3b.dist.topo.correct.incorrect.difference.wave <- p3b.topo.correct.incorrect.difference.wave %>% filter(t == 500)
```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = p3b.dist.topo.correct.incorrect.difference.wave$x,
                     y = p3b.dist.topo.correct.incorrect.difference.wave$y,
                     z = p3b.dist.topo.correct.incorrect.difference.wave$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = p3b.dist.topo.correct.incorrect.difference.wave,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = p3b.dist.topo.correct.incorrect.difference.wave,
             aes(x,y, color=key_electrode),
             size = 1.5)+
  scale_color_manual(values=c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-1,1),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```

```{r}
maskRing <- circleFun(r = 2.65) #create a circle round the outside of the plotting area to mask the jagged edges of the interpolation

## Create data frame to be used for interpolation - the function needs columns labelled x, y, and z

testDat<- data.frame(x = p3b.target.topo.correct.incorrect.difference.wave$x,
                     y = p3b.target.topo.correct.incorrect.difference.wave$y,
                     z = p3b.target.topo.correct.incorrect.difference.wave$amplitude)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo)

interpV4 <- gather(interpV4,
                   key = y,
                   value = amplitude,
                   -x,
                   convert = TRUE) 

interpV4$incircle <- (interpV4$x)^2 + (interpV4$y)^2 < 2.65 ^ 2 # mark #2.65 ^ 2

v4plot <- ggplot(interpV4[interpV4$incircle,],aes(x = x, y = y, fill = amplitude))+
  geom_raster()+
  stat_contour(aes(z = amplitude),binwidth = 0.5)+
  theme_topo()+
   geom_path(data = maskRing,
            aes(x, y, z = NULL, fill =NULL),
            colour = "white",
            size = 6)+
  geom_point(data = p3b.target.topo.correct.incorrect.difference.wave,
             aes(x,y), color="black",
             size = 1.9)+
  geom_point(data = p3b.target.topo.correct.incorrect.difference.wave,
             aes(x,y, color=key_electrode),
             size = 1.5)+
  scale_color_manual(values=c("white", "grey30")) +
  scale_fill_gradientn(colours = jet.colors(10),
                       limits = c(-1.25,1.25),
                       guide = "colourbar",
                       oob = squish)+
  head +
  nose_shape +
  coord_equal()

v4plot
```